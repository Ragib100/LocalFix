CREATE TABLE applications (
    application_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    job_id NUMBER NOT NULL,
    worker_id NUMBER NOT NULL,
    estimated_cost NUMBER(10,2) NOT NULL,
    estimated_time VARCHAR2(50) NOT NULL,
    proposal_description CLOB,
    status_id NUMBER DEFAULT 1,
    reviewed_by NUMBER,
    feedback CLOB,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP
);

-- Add foreign key constraints
ALTER TABLE applications ADD CONSTRAINT fk_applications_job 
    FOREIGN KEY (job_id) REFERENCES jobs(job_id) ON DELETE CASCADE;

ALTER TABLE applications ADD CONSTRAINT fk_applications_worker 
    FOREIGN KEY (worker_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE applications ADD CONSTRAINT fk_applications_status 
    FOREIGN KEY (status_id) REFERENCES application_status(status_id);

ALTER TABLE applications ADD CONSTRAINT fk_applications_reviewer 
    FOREIGN KEY (reviewed_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add simple check constraints (no subqueries)
ALTER TABLE applications ADD CONSTRAINT chk_applications_cost 
    CHECK (estimated_cost > 0);

-- Add unique constraint to prevent duplicate applications
ALTER TABLE applications ADD CONSTRAINT uk_applications_job_worker 
    UNIQUE (job_id, worker_id);

-- Create indexes
CREATE INDEX idx_applications_job ON applications(job_id);
CREATE INDEX idx_applications_worker ON applications(worker_id);
CREATE INDEX idx_applications_status ON applications(status_id);
CREATE INDEX idx_applications_applied_at ON applications(applied_at);

-- Business logic validation through triggers (not CHECK constraints)
CREATE OR REPLACE TRIGGER trg_applications_insert_validate
    BEFORE INSERT ON applications
    FOR EACH ROW
DECLARE
    worker_type VARCHAR2(20);
    job_status_id NUMBER;
BEGIN
    -- Validate that applicant is a worker
    SELECT user_type INTO worker_type 
    FROM users WHERE user_id = :NEW.worker_id;
    
    IF worker_type != 'worker' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Only workers can submit applications');
    END IF;
    
    -- Validate that job is open for applications
    SELECT status_id INTO job_status_id 
    FROM jobs WHERE job_id = :NEW.job_id;
    
    IF job_status_id != 1 THEN  -- not 'open'
        RAISE_APPLICATION_ERROR(-20003, 'Job is not open for applications');
    END IF;
END;
/

-- Trigger for application acceptance (Corrected with Compound Trigger)
CREATE OR REPLACE TRIGGER trg_applications_status_update
FOR UPDATE OF status_id ON applications
COMPOUND TRIGGER

    -- A collection to store details of accepted applications
    TYPE accepted_app_rec IS RECORD (
        job_id        NUMBER,
        application_id NUMBER,
        worker_id     NUMBER,
        reviewed_by   NUMBER
    );
    TYPE accepted_app_list IS TABLE OF accepted_app_rec INDEX BY PLS_INTEGER;
    g_accepted_apps accepted_app_list;

    -- This runs after each row is updated
    AFTER EACH ROW IS
    BEGIN
        -- Check if an application is being accepted
        IF :NEW.status_id = 3 AND (:OLD.status_id IS NULL OR :OLD.status_id != 3) THEN

            -- 1. Update the associated job to 'assigned'. This is safe as it's a different table.
            UPDATE jobs
            SET status_id = 2,  -- 'assigned' status
                assigned_worker_id = :NEW.worker_id,
                updated_at = CURRENT_TIMESTAMP
            WHERE job_id = :NEW.job_id;

            -- 2. Store the details of this accepted application in our collection for later.
            g_accepted_apps(g_accepted_apps.COUNT + 1).job_id := :NEW.job_id;
            g_accepted_apps(g_accepted_apps.COUNT + 1).application_id := :NEW.application_id;
            g_accepted_apps(g_accepted_apps.COUNT + 1).reviewed_by := :NEW.reviewed_by;
        END IF;
    END AFTER EACH ROW;

    -- This runs once after the entire UPDATE statement is finished
    AFTER STATEMENT IS
    BEGIN
        -- If we have any accepted applications in our collection...
        IF g_accepted_apps.COUNT > 0 THEN
            FOR i IN 1..g_accepted_apps.COUNT LOOP
                -- 3. Now it's safe to update the applications table again.
                -- Reject all other pending applications for the same job.
                UPDATE applications
                SET status_id = 4,  -- 'rejected' status
                    reviewed_at = CURRENT_TIMESTAMP,
                    reviewed_by = g_accepted_apps(i).reviewed_by
                WHERE job_id = g_accepted_apps(i).job_id
                  AND application_id != g_accepted_apps(i).application_id
                  AND status_id IN (1, 2);  -- submitted or under_review
            END LOOP;
        END IF;
    END AFTER STATEMENT;

END trg_applications_status_update;
/

COMMIT;