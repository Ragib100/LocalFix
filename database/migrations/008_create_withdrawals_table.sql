-- Withdrawals table for worker payouts
-- Save as: database/migrations/019_create_withdrawals_table.sql
CREATE TABLE withdrawals (
    withdrawal_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    worker_id NUMBER NOT NULL,
    method VARCHAR2(30) NOT NULL CHECK (method IN ('bkash','nagad','rocket','sonali_bank')),
    account_number VARCHAR2(50) NOT NULL,
    amount NUMBER(10,2) NOT NULL CHECK (amount > 0),
    status VARCHAR2(20) DEFAULT 'processing' CHECK (status IN ('processing','successful','failed')),
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP,
    transaction_id VARCHAR2(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_withdrawals_worker FOREIGN KEY (worker_id) REFERENCES users(user_id) ON DELETE CASCADE
);

CREATE INDEX idx_withdrawals_worker ON withdrawals(worker_id);
CREATE INDEX idx_withdrawals_status ON withdrawals(status);
CREATE INDEX idx_withdrawals_requested ON withdrawals(requested_at);

CREATE OR REPLACE TRIGGER trg_withdrawals_updated_at
    BEFORE UPDATE ON withdrawals
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

COMMIT;

-- View combining issues with citizen and location for convenient reads
CREATE OR REPLACE VIEW v_issues_with_details AS
SELECT 
  i.issue_id,
  i.title,
  i.description,
  i.category,
  i.priority,
  i.status,
  i.image_url,
  i.assigned_worker_id,
  i.created_at,
  i.updated_at,
  l.full_address,
  l.upazila,
  l.district,
    l.latitude,
    l.longitude,
  u.name   AS citizen_name,
  u.phone  AS citizen_phone,
  u.email  AS citizen_email
FROM issues i
LEFT JOIN users u ON i.citizen_id = u.user_id
LEFT JOIN locations l ON i.location_id = l.location_id;

-- Function: get_issue_count_by_status
-- Returns number of issues for a worker in a given status.
CREATE OR REPLACE FUNCTION get_issue_count_by_status(
    p_worker_id IN NUMBER,
    p_status    IN VARCHAR2
) RETURN NUMBER
AS
    v_count NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM issues
    WHERE assigned_worker_id = p_worker_id
      AND status = p_status;
    RETURN NVL(v_count, 0);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        -- Basic exception handling demo for sessional
        RETURN 0;
END;
/

-- Procedure: set_issue_status_safe
-- Safely sets issue status with validation and exception handling.
CREATE OR REPLACE PROCEDURE set_issue_status_safe(
    p_issue_id IN NUMBER,
    p_status   IN VARCHAR2
) AS
    v_valid NUMBER;
BEGIN
    -- Validate target status is allowed
    SELECT COUNT(*) INTO v_valid
    FROM (
        SELECT 'submitted' AS s FROM dual UNION ALL
        SELECT 'applied' FROM dual UNION ALL
        SELECT 'assigned' FROM dual UNION ALL
        SELECT 'in_progress' FROM dual UNION ALL
        SELECT 'under_review' FROM dual UNION ALL
        SELECT 'resolved' FROM dual UNION ALL
        SELECT 'closed' FROM dual
    )
    WHERE s = p_status;

    IF v_valid = 0 THEN
        RAISE_APPLICATION_ERROR(-20020, 'Invalid status');
    END IF;

    UPDATE issues
    SET status = p_status,
        updated_at = CURRENT_TIMESTAMP
    WHERE issue_id = p_issue_id;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20021, 'Issue not found');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Re-raise with a consistent application error number
        RAISE_APPLICATION_ERROR(-20022, 'Failed to set status: ' || SQLERRM);
END;
/

-- Summary view demonstrating GROUP BY: worker earnings by status
CREATE OR REPLACE VIEW v_worker_payment_summary AS
SELECT 
    p.worker_id,
    p.payment_status,
    COUNT(*) AS payment_count,
    SUM(p.amount) AS total_amount,
    MIN(p.payment_date) AS first_payment,
    MAX(p.payment_date) AS last_payment
FROM payments p
GROUP BY p.worker_id, p.payment_status;

COMMIT;
