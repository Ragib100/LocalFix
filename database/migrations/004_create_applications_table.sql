-- Modified applications table with reviewed_by column
CREATE TABLE applications (
    application_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    issue_id NUMBER NOT NULL,
    worker_id NUMBER NOT NULL,
    estimated_cost NUMBER(10,2) NOT NULL,
    estimated_time VARCHAR2(50) NOT NULL,
    proposal_description CLOB,
    status VARCHAR2(20) DEFAULT 'submitted' CHECK (status IN ('submitted', 'accepted', 'rejected')),
    feedback CLOB,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP,
    reviewed_by NUMBER -- Admin who reviewed the application
);

-- Add foreign key constraints
ALTER TABLE applications ADD CONSTRAINT fk_applications_issue 
    FOREIGN KEY (issue_id) REFERENCES issues(issue_id) ON DELETE CASCADE;

ALTER TABLE applications ADD CONSTRAINT fk_applications_worker 
    FOREIGN KEY (worker_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE applications ADD CONSTRAINT fk_applications_reviewed_by 
    FOREIGN KEY (reviewed_by) REFERENCES users(user_id);

-- Add simple check constraints
ALTER TABLE applications ADD CONSTRAINT chk_applications_cost 
    CHECK (estimated_cost > 0);

-- Add unique constraint to prevent duplicate applications
ALTER TABLE applications ADD CONSTRAINT uk_applications_issue_worker 
    UNIQUE (issue_id, worker_id);

-- Create indexes
CREATE INDEX idx_applications_issue ON applications(issue_id);
CREATE INDEX idx_applications_worker ON applications(worker_id);
CREATE INDEX idx_applications_status ON applications(status);
CREATE INDEX idx_applications_applied_at ON applications(applied_at);
CREATE INDEX idx_applications_reviewed_by ON applications(reviewed_by);

-- Trigger for auto-updating reviewed_at when status changes
CREATE OR REPLACE TRIGGER trg_applications_reviewed_at
    BEFORE UPDATE OF status ON applications
    FOR EACH ROW
    WHEN (NEW.status IN ('accepted', 'rejected'))
DECLARE
    admin_type VARCHAR2(20);
BEGIN
    -- Validate that only admins can change status to accepted/rejected
    IF :NEW.reviewed_by IS NOT NULL THEN
        SELECT user_type INTO admin_type 
        FROM users WHERE user_id = :NEW.reviewed_by;
        
        IF admin_type != 'admin' THEN
            RAISE_APPLICATION_ERROR(-20010, 'Only admins can review applications');
        END IF;
    END IF;
    
    :NEW.reviewed_at := CURRENT_TIMESTAMP;
END;
/

-- Business logic validation through triggers
CREATE OR REPLACE TRIGGER trg_applications_insert_validate
    BEFORE INSERT ON applications
    FOR EACH ROW
DECLARE
    worker_type VARCHAR2(20);
    issue_status VARCHAR2(20);
BEGIN
    -- Validate that applicant is a worker
    SELECT user_type INTO worker_type 
    FROM users WHERE user_id = :NEW.worker_id;
    
    IF worker_type != 'worker' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Only workers can submit applications');
    END IF;
    
    -- Validate that issue is open for applications (submitted or applied status)
    SELECT status INTO issue_status 
    FROM issues WHERE issue_id = :NEW.issue_id;
    
    IF issue_status NOT IN ('submitted', 'applied') THEN
        RAISE_APPLICATION_ERROR(-20003, 'Issue is not open for applications');
    END IF;
END;
/

-- Trigger for application acceptance workflow
CREATE OR REPLACE TRIGGER trg_applications_status_update
FOR UPDATE OF status ON applications
COMPOUND TRIGGER

    -- Collection to store details of accepted applications
    TYPE accepted_app_rec IS RECORD (
        issue_id       NUMBER,
        application_id NUMBER,
        worker_id      NUMBER,
        reviewed_by    NUMBER
    );
    TYPE accepted_app_list IS TABLE OF accepted_app_rec INDEX BY PLS_INTEGER;
    g_accepted_apps accepted_app_list;

    -- This runs after each row is updated
    AFTER EACH ROW IS
    BEGIN
        -- Check if an application is being accepted
        IF :NEW.status = 'accepted' AND (:OLD.status IS NULL OR :OLD.status != 'accepted') THEN

            -- Update the associated issue to 'assigned' status
            UPDATE issues
            SET status = 'assigned',
                assigned_worker_id = :NEW.worker_id,
                updated_at = CURRENT_TIMESTAMP
            WHERE issue_id = :NEW.issue_id;

            -- Store the details of this accepted application for later processing
            g_accepted_apps(g_accepted_apps.COUNT + 1).issue_id := :NEW.issue_id;
            g_accepted_apps(g_accepted_apps.COUNT).application_id := :NEW.application_id;
            g_accepted_apps(g_accepted_apps.COUNT).worker_id := :NEW.worker_id;
            g_accepted_apps(g_accepted_apps.COUNT).reviewed_by := :NEW.reviewed_by;
        END IF;
    END AFTER EACH ROW;

    -- This runs once after the entire UPDATE statement is finished
    AFTER STATEMENT IS
    BEGIN
        -- If we have any accepted applications in our collection...
        IF g_accepted_apps.COUNT > 0 THEN
            FOR i IN 1..g_accepted_apps.COUNT LOOP
                -- Reject all other pending applications for the same issue
                UPDATE applications
                SET status = 'rejected',
                    reviewed_at = CURRENT_TIMESTAMP,
                    reviewed_by = g_accepted_apps(i).reviewed_by
                WHERE issue_id = g_accepted_apps(i).issue_id
                  AND application_id != g_accepted_apps(i).application_id
                  AND status IN ('submitted', 'under_review');
            END LOOP;
        END IF;
        
        -- Clear the collection for next use
        g_accepted_apps.DELETE;
    END AFTER STATEMENT;

END trg_applications_status_update;
/

COMMIT;