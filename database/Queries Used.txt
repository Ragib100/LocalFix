1. Grant, Revoke (000_database_setup.sql) -> to create dedicated user
-- To drop user: 
DROP USER local CASCADE;

CREATE USER local IDENTIFIED BY fix;

-- Minimum privileges for app development
GRANT CREATE SESSION TO local;
GRANT CREATE TABLE TO local;
GRANT CREATE SEQUENCE TO local;
GRANT CREATE TRIGGER TO local;
GRANT CREATE VIEW TO local;
GRANT CREATE PROCEDURE TO local;
GRANT UNLIMITED TABLESPACE TO local;

-- Revoke privileges
REVOKE CREATE PROCEDURE FROM local;

2. Constraints (Used in almost every table)
001_create_users_table.sql:
CREATE TABLE users (
    user_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    phone VARCHAR2(11) NOT NULL,
    address VARCHAR2(255) NOT NULL,
    hashed_pass VARCHAR2(255) NOT NULL,
    user_type VARCHAR2(20) CHECK (user_type IN ('citizen', 'worker', 'admin')) NOT NULL,
    status VARCHAR2(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
    img_url VARCHAR2(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

004_create_applications_table.sql:
ALTER TABLE applications ADD CONSTRAINT fk_applications_worker FOREIGN KEY (worker_id) REFERENCES users(user_id) ON DELETE CASCADE;

3. Trigger, Sequence, INDEX
(001_create_users_table.sql)
CREATE INDEX idx_users_type ON users(user_type);

(001_create_users_table.sql)
CREATE OR REPLACE TRIGGER trg_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;

(006_create_payments_table.sql)
DECLARE
    v_exists NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO v_exists 
    FROM user_sequences 
    WHERE sequence_name = 'SEQ_PAYMENT_TX';
    IF v_exists = 0 THEN
        EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_payment_tx START WITH 1000 INCREMENT BY 1 NOCACHE';
    END IF;
END;

4. View & Group By:(008_create_withdrawals_table.sql)
CREATE OR REPLACE VIEW v_worker_payment_summary AS
SELECT 
    p.worker_id,
    p.payment_status,
    COUNT(*) AS payment_count,
    SUM(p.amount) AS total_amount,
    MIN(p.payment_date) AS first_payment,
    MAX(p.payment_date) AS last_payment
FROM payments p
GROUP BY p.worker_id, p.payment_status;

(Using view in the issueController.js)
SELECT 
        issue_id, title, description, category, priority, image_url, status,
        created_at, updated_at, citizen_name, citizen_email, citizen_phone,
        full_address as location_address, upazila, district, latitude, longitude
       FROM v_issues_with_details
       ORDER BY created_at DESC

5. Simple and complex queries (using subqueries, join etc.)
Create:(In constraint)
SELECT:(User.js)
SELECT hashed_pass FROM users WHERE user_id = :user_id

Insert:(User.js)
INSERT INTO users (name, email, phone, address, hashed_pass, user_type)
                     VALUES (:name, :email, :phone, :address, :hashed_pass, :user_type)
                     RETURNING user_id INTO :user_id

Update:(User.js)
UPDATE users SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP 
                     WHERE user_id = :user_id

Delete:(User.js)
DELETE FROM users WHERE user_id = :user_id

workerController.js: (complex subquery, join, ORDER by)
SELECT
        i.issue_id,
        i.title,
        TO_CHAR(i.description) as description,
        i.category,
        i.priority,
        i.status,
        i.image_url,
        l.full_address,
        l.upazila,
        l.district,
        c.name as citizen_name,
        c.phone as citizen_phone,
        CAST(NULL AS TIMESTAMP) as applied_at,
        CAST(NULL AS VARCHAR2(20)) as application_status,
        CAST(NULL AS NUMBER) as estimated_cost,
        CAST(NULL AS VARCHAR2(50)) as estimated_time,
        CAST(NULL AS VARCHAR2(4000)) as my_proposal,
        CAST(NULL AS VARCHAR2(4000)) as admin_feedback,
        i.updated_at as last_updated
    FROM issues i
    JOIN users c ON i.citizen_id = c.user_id
    JOIN locations l ON i.location_id = l.location_id
    WHERE i.assigned_worker_id = :worker_id 
      AND i.status IN ('assigned', 'in_progress', 'under_review', 'resolved')
      AND NOT EXISTS (
        SELECT 1 FROM applications a2 
        WHERE a2.issue_id = i.issue_id AND a2.worker_id = :worker_id
      )
    ORDER BY last_updated DESC


6. ADT & records
CREATE OR REPLACE TRIGGER trg_applications_status_update
FOR UPDATE OF status ON applications
COMPOUND TRIGGER

    -- Collection to store details of accepted applications
    TYPE accepted_app_rec IS RECORD (
        issue_id       NUMBER,
        application_id NUMBER,
        worker_id      NUMBER,
        reviewed_by    NUMBER
    );
    TYPE accepted_app_list IS TABLE OF accepted_app_rec INDEX BY PLS_INTEGER;
    g_accepted_apps accepted_app_list;

    -- This runs after each row is updated
    AFTER EACH ROW IS
    BEGIN
        -- Check if an application is being accepted
        IF :NEW.status = 'accepted' AND (:OLD.status IS NULL OR :OLD.status != 'accepted') THEN

            -- Update the associated issue to 'assigned' status
            UPDATE issues
            SET status = 'assigned',
                assigned_worker_id = :NEW.worker_id,
                updated_at = CURRENT_TIMESTAMP
            WHERE issue_id = :NEW.issue_id;

            -- Store the details of this accepted application for later processing
            g_accepted_apps(g_accepted_apps.COUNT + 1).issue_id := :NEW.issue_id;
            g_accepted_apps(g_accepted_apps.COUNT).application_id := :NEW.application_id;
            g_accepted_apps(g_accepted_apps.COUNT).worker_id := :NEW.worker_id;
            g_accepted_apps(g_accepted_apps.COUNT).reviewed_by := :NEW.reviewed_by;
        END IF;
    END AFTER EACH ROW;

    -- This runs once after the entire UPDATE statement is finished
    AFTER STATEMENT IS
    BEGIN
        -- If we have any accepted applications in our collection...
        IF g_accepted_apps.COUNT > 0 THEN
            FOR i IN 1..g_accepted_apps.COUNT LOOP
                -- Reject all other pending applications for the same issue
                UPDATE applications
                SET status = 'rejected',
                    reviewed_at = CURRENT_TIMESTAMP,
                    reviewed_by = g_accepted_apps(i).reviewed_by
                WHERE issue_id = g_accepted_apps(i).issue_id
                  AND application_id != g_accepted_apps(i).application_id
                  AND status IN ('submitted', 'under_review');
            END LOOP;
        END IF;
        
        -- Clear the collection for next use
        g_accepted_apps.DELETE;
    END AFTER STATEMENT;

END trg_applications_status_update;

7. Function, Procedure, Exception handling
(008_create_withdrawals_table.sql)
-- Function: get_issue_count_by_status
-- Returns number of issues for a worker in a given status.
CREATE OR REPLACE FUNCTION get_issue_count_by_status(
    p_worker_id IN NUMBER,
    p_status    IN VARCHAR2
) RETURN NUMBER
AS
    v_count NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM issues
    WHERE assigned_worker_id = p_worker_id
      AND status = p_status;
    RETURN NVL(v_count, 0);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        -- Basic exception handling demo for sessional
        RETURN 0;
END;
/

-- Procedure: set_issue_status_safe
-- Safely sets issue status with validation and exception handling.
CREATE OR REPLACE PROCEDURE set_issue_status_safe(
    p_issue_id IN NUMBER,
    p_status   IN VARCHAR2
) AS
    v_valid NUMBER;
BEGIN
    -- Validate target status is allowed
    SELECT COUNT(*) INTO v_valid
    FROM (
        SELECT 'submitted' AS s FROM dual UNION ALL
        SELECT 'applied' FROM dual UNION ALL
        SELECT 'assigned' FROM dual UNION ALL
        SELECT 'in_progress' FROM dual UNION ALL
        SELECT 'under_review' FROM dual UNION ALL
        SELECT 'resolved' FROM dual UNION ALL
        SELECT 'closed' FROM dual
    )
    WHERE s = p_status;

    IF v_valid = 0 THEN
        RAISE_APPLICATION_ERROR(-20020, 'Invalid status');
    END IF;

    UPDATE issues
    SET status = p_status,
        updated_at = CURRENT_TIMESTAMP
    WHERE issue_id = p_issue_id;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20021, 'Issue not found');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Re-raise with a consistent application error number
        RAISE_APPLICATION_ERROR(-20022, 'Failed to set status: ' || SQLERRM);
END;

(Peocedure used in issueController.js):
// Use stored procedure for validated status update (demonstrates PL/SQL usage)
    const callResult = await executeQuery(
      `BEGIN set_issue_status_safe(:id, :status); END;`,
      { id, status }
    );
